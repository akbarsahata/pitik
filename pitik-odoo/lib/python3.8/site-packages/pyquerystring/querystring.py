# -*- coding: utf-8 -*-
from .compat import parse_qsl
from .compat import is_py3


def parse(data):
    obj = QueryStringParser(data)
    return obj.result


class QueryStringToken(object):

    ARRAY = "ARRAY"
    OBJECT = "OBJECT"
    KEY = "KEY"


class DefaultList(list):
    def __setitem__(self, index, value):
        size = len(self)
        if index >= size:
            self.extend(None for _ in range(size, index + 1))
        list.__setitem__(self, index, value)


class QueryStringParser(object):

    def __init__(self, data):
        self.result = {}

        if isinstance(data, str):
            sorted_pairs = self._sorted_from_string(data)
        else:
            sorted_pairs = self._sorted_from_obj(data)
        [self.process(k, v) for k, v in sorted_pairs]

    def _sorted_from_string(self, data):
        stage1 = parse_qsl(data)
        stage2 = [(x[0].strip(), x[1].strip()) for x in stage1]
        return sorted(stage2, key=lambda p: p[0])

    def _sorted_from_obj(self, data):
        # data is a list of the type generated by parse_qsl
        if isinstance(data, list):
            items = data
        else:
            # complex objects:
            try:
                # django.http.QueryDict,
                items = [(i[0], j) for i in data.lists() for j in i[1]]
            except AttributeError:
                # webob.multidict.MultiDict
                # werkzeug.datastructures.MultiDict
                if is_py3:
                    items = data.items()
                else:
                    items = data.iteritems()

        return sorted(items, key=lambda p: p[0])

    def process(self, key, value):
        """

        Given a key-value pair, assign the value to the location specified by
        the key in the result attribute.

        >>> self.process('id[0]', 'foo')
        self.result['id'][0] = 'foo'

        """

        try:
            self.parse(key, value)
        except ValueError:
            self.result[key] = value

    def parse(self, key, value):
        """
        Break the key into tokens to determine where to assign the value
        """

        ref = self.result
        tokens = self.tokens(key)

        for token in tokens:
            token_type, key = token
            if token_type == QueryStringToken.ARRAY:
                if key not in ref:
                    ref[key] = DefaultList()
                ref = ref[key]

            elif token_type == QueryStringToken.OBJECT:
                if key not in ref:
                    ref[key] = {}
                ref = ref[key]

            elif token_type == QueryStringToken.KEY:
                try:
                    if ref[key] is None or type(ref[key]) not in (DefaultList, dict):
                        raise KeyError
                    # This key exists as list or dict. Traverse down the tree.
                    ref = ref[key]
                    next(tokens)
                # TypeError is for pet[]=lucy&pet[]=ollie
                # if the array key is empty a type error will be raised
                except (IndexError, KeyError, TypeError):
                    # the index didn't exist
                    # so we look ahead to see what we are setting
                    # there is not a next token
                    # set the value
                    try:
                        next_token = next(tokens)
                        if next_token[0] == QueryStringToken.ARRAY:
                            ref[key] = DefaultList()
                            ref = ref[key]
                        elif next_token[0] == QueryStringToken.OBJECT:
                            try:
                                ref[key] = {}
                            except IndexError:
                                ref.append({})

                            ref = ref[key]
                    except StopIteration:
                        if key is None:
                            ref.append(value)
                        else:
                            ref[key] = value
                        return

    def tokens(self, key):
        """
        Returns an iterator of the array elements (tokens) of a given key
        """
        buf = ""

        # remove white space from any keys
        key = key.replace(" ", "")

        # Creates iterator of next chars
        in_array_bracket = 0
        pre_array_buffer = ''
        for char in key:
            if char == "[":
                in_array_bracket += 1
                if in_array_bracket == 1:
                    pre_array_buffer = buf
                    buf = ""
                else:
                    buf = buf + char

            elif char == "." and in_array_bracket == 0:
                yield QueryStringToken.OBJECT, buf
                buf = ""

            elif char == "]":
                in_array_bracket -= 1
                if in_array_bracket < 0:
                    raise IOError('Non-matching close bracket in querystring')
                if in_array_bracket == 0:
                    if buf.isdigit():
                        yield QueryStringToken.ARRAY, pre_array_buffer
                        yield QueryStringToken.KEY, int(buf)
                    elif buf == '':
                        yield QueryStringToken.ARRAY, pre_array_buffer
                        yield QueryStringToken.KEY, None
                    else:
                        yield QueryStringToken.OBJECT, pre_array_buffer
                        yield QueryStringToken.KEY, buf
                    buf = ""
                else:
                    buf = buf + char
            else:
                buf = buf + char

        if len(buf) > 0:
            yield QueryStringToken.KEY, buf
        else:
            return
